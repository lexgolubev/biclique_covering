package by.bsu.binarytree.domain;

import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Scanner;

import by.bsu.binarytree.alg.Algorithms;
import by.bsu.binarytree.util.SPTreeException;

public class SPTree {
	private ArrayList<Node> tree = new ArrayList<Node>();
	private static final int INF = 10000000;
	private static final int NUMBER_OF_PROPERTIES = 6;
	private static final int MAX_MASK = 1 << NUMBER_OF_PROPERTIES;;

	private void buildEmptyTree(int size) {
		tree.clear();
		for (int i = 0; i < size + 1; i++) {
			Node node = new Node();
			node.type = NodeType.EMPTY;
			node.left = -1;
			node.right = -1;
			tree.add(node);
		}
	}

	public void loadFromFile(String fileName) throws IOException,
			SPTreeException {
		Integer prev;
		Integer type;
		if (fileName.equals("")) {
			return;
		}
		// load data from file
		FileReader fin = new FileReader(fileName);
		Scanner inFile = new Scanner(fin);
		if (inFile.hasNextInt()) {
			buildEmptyTree(inFile.nextInt());
		} else {
			throw new SPTreeException("Incrrect File Structure");
		}
		int count = 0;
		try {
			while (inFile.hasNext()) {
				count++;
				prev = new Integer(inFile.next());
				type = new Integer(inFile.next());
				tree.get(count).type = NodeType.getByValue(type);
				if (prev >= 0) {
					if (tree.get(prev).left == -1) {
						tree.get(prev).left = count;
						// System.out.println(prev + " left " + count);
					} else {
						tree.get(prev).right = count;
						// System.out.println(prev + " right " + count);
					}
				}
			}
		} catch (SPTreeException e) {
			throw new SPTreeException("Node type is out of range");
		} finally {
			fin.close();
			inFile.close();
		}
	}

	public void printTree() {
		int count = 0;
		for (Node node : tree) {
			if (node.left > 0) {
				System.out.println(count + " left" + node.left);
			}
			if (node.right > 0) {
				System.out.println(count + " right" + node.right);
			}
			count++;
		}
	}

	public int[] generateBC(int nodeNumber) throws SPTreeException {
		int i;
		int[] hc;
		char flag = ' ';

		if (nodeNumber == -1) {
			throw new SPTreeException("Bad node number");
		}

		switch (tree.get(nodeNumber).type) {
		case LEAF:
			hc = leafFunction();
			break;
		case SEQ:
			hc = spFunction('s', nodeNumber);
			break;
		case PAR:
			hc = spFunction('p', nodeNumber);
			break;
		default:
			throw new SPTreeException("Wrong type of vertex number "
					+ tree.get(nodeNumber).type);
		}

		return hc;
	}

	public void bc() throws SPTreeException {
		int[] bc = generateBC(1);
		int result = INF;

		int resmask = -1;

		for (int i = 0; i < MAX_MASK; ++i)
			if (!((Algorithms.GB(i, 5) || Algorithms.GB(i, 6)) && !Algorithms
					.GB(i, 1))) {

				if (bc[i] < result) {
					result = bc[i];
					// result = min (result, bc[i]);
					resmask = i;
				}
			}

		System.out.println(result);
		System.out.println(resmask);
	}

	public static int[] leafFunction() {
		int[] hc = new int[MAX_MASK];
		for (int i = 0; i < MAX_MASK; ++i) {
			hc[i] = INF;
		}
		hc[1] = 1;
		hc[2] = 1;
		hc[4] = 1;
		return hc;
	}

	public int[] spFunction(char flag, int nodeNumber) throws SPTreeException {
		int[] ha;
		int[] hb;
		int[] hc;
		ha = generateBC(tree.get(nodeNumber).left);
		hb = generateBC(tree.get(nodeNumber).right);

		hc = new int[MAX_MASK];
		for (int i = 0; i < MAX_MASK; ++i) {

			hc[i] = INF;
		}

		int currw;

		for (int i = 0; i < MAX_MASK; ++i)
			if (ha[i] != INF)
				for (int j = 0; j < MAX_MASK; ++j)
					if (hb[j] != INF)
						for (int k = 0; k < MAX_MASK; ++k) {

							currw = Algorithms.findDiff(flag, i, j, k);

							if (currw >= 0) {
								if (hc[k] > ha[i] + hb[j] - currw) {
									hc[k] = ha[i] + hb[j] - currw;

									System.out.print(nodeNumber
											+ " c= "
											+ Algorithms.gbString(k,
													NUMBER_OF_PROPERTIES)
											+ " hc= " + hc[k]);
									System.out.print(" a= "
											+ Algorithms.gbString(i,
													NUMBER_OF_PROPERTIES)
											+ " ha= " + ha[i]);
									System.out.println(" b= "
											+ Algorithms.gbString(j,
													NUMBER_OF_PROPERTIES)
											+ " hb= " + hb[j]);

								}

								// hc[k] = min(ha[i] + hb[j] - currw, hc[k]);
							}
						}
		return hc;
	}

}